#+TITLE: On the Practical Study of S-Boxes

* 1) Foreword
This document was created for the [[https://casa.rub.de/en/spring-school-on-symmetric-cryptography][spring school]] co-located with [[https://fse.iacr.org/2025/][Fast Software Encryption 2025]] by me, [[https://who.paris.inria.fr/Leo.Perrin/][LÃ©o Perrin]].

/You are probably reading this content as nicely formatted markdown on github (namely, [[https://github.com/lpp-crypto/FSE2025-spring-school/tree/main/STAP-Exercises][here]]), which is absolutely fine. However, it is actually an [[https://orgmode.org/][orgmode]] file that is best appreciated by opening directly the [[https://github.com/lpp-crypto/FSE2025-spring-school/tree/main/STAP-Exercises/readme.org][readme.org]] in [[https://en.wikipedia.org/wiki/GNU_Emacs][emacs]]./

* 2) Basics of SAGE/Python
** 2.1) Python
[[https://en.wikipedia.org/wiki/Python_(programming_language)][Python]] is a programming language with a simple syntax that, for our purposes, allows programmers to easily implement sophisticated programs (thus minimizing the time needed to prototype, say, an attack). Its main downside is its speed (or the lack thereof).

A python script is interpreted, meaning that it is not compiled. To run a python script, just type =python /path/to/your/script.py= and watch it go! Python is a quick language to learn, so even if you are not familiar with its specific, you should be fine during this class. We will see some more advanced features (and their relevance) later. If you have never used python, you mostly need to remember that *indentation has semantic value*: the following two programs are completely different.

In this first one, the =else= clause corresponds to the =if (i<2)= in  the main loop...
#+BEGIN_SRC python :results output
if (1 < 3):
    for i in range(0, 5):
        if (i < 2):
            print(i)
        else:
            print("else entered")
#+END_SRC

#+RESULTS:
: 0
: 1
: else entered
: else entered
: else entered


... But in this second one, it is never entered since it corresponding instead to =if (1<3)=, which is always true.
#+BEGIN_SRC python :results output
if (1 < 3):
    for i in range(0, 5):
        if (i < 2):
            print(i)
else:
    print("else entered")
#+END_SRC

#+RESULTS:
: 0
: 1

** 2.2) SAGE
[[https://www.sagemath.org/][SAGE]] can be seen as a super-set of Python. It comes bundled with libraries that can do *a lot* of scientific computations. In particular for us, it implements finite field arithmetic, and contains by default some basic tools to study S-boxes.

** 2.3) sboxU
[[https://github.com/lpp-crypto/sboxU][sboxU]] is a library specifically intended to study S-boxes, that you can =import= from SAGE once you have properly installed. Instructions to this end are available on its repository ([[https://github.com/lpp-crypto/sboxU][here]]). Unlike "regular" Python programs, =sboxU= must be compiled: large chunks of it are written in =C++= for speed. We will see how that works on Friday (see [[https://github.com/lpp-crypto/FSE2025-spring-school/tree/main/Tools#adding-some-c-to-it][here]]).

* 3) The Core Tools to Study S-boxes
SAGE comes bundled with some tools (in particular, the =sage.crypto.sboxes= and =sage.crypto.sbox= modules), and =sboxU= provides additional ones. Let's have a look what we can do combining these two.

** 3.1) The list of all S-boxes
SAGE contains a list of all known S-boxes, that is updated every now and then. Its focus is on S-boxes that are used in block ciphers, hash functions, etc. from the literature, but there are also S-boxes that were identified in more mathematical papers. They are in the =sage.crypto.sboxes= module, which can be used for example as follows.

#+BEGIN_SRC python
from sage.crypto.sboxes import sboxes
#+END_SRC

In this case, =sboxes= is a dictionary where the keys are algorithm names, and the entries are =sage.crypto.sbox.SBox= instances containing their lookup tables. 

- Q? :: Print the lookup table of the S-boxes of the =PRESENT= block cipher. Print the length (in the Python sense) of this object. Anything strange?
- Q? :: Print the lookup tables of all the S-boxes of the =SERPENT= block cipher.
  
** 3.2) The Tables
Some of the following functions also work for field $F_q$ where $q = p^n$ with $p > 2$, but we won't get into that today.
*** 3.2.a) Differential Properties
The *Difference Distribution Table (DDT)* of an S-box =s= over =n= bits is a two dimensional array =d= such that, in our case:
#+BEGIN_SRC python
d[a][b] = len([x for x in range(0, 2**n) if s[x^a] = s[x]^b])
#+END_SRC

The *differential spectrum* counts how many pairs =(a,b)= exist such that =d[a][b] = c=, where =a!=0=. The maximum non-zero coefficient in this spectrum is the *differential uniformity* of =s=.

**** 3.2.a.i) Using pure SAGE
To compute the DDT of the S-box of the PRINCE block cipher, and then its differential spectrum, we do as follows.

#+BEGIN_SRC python
from sage.crypto.sbox import SBox  # we import the SBox class
from collections import defaultdict # a dictionary replacement

lut = SBox([11, 15, 3, 2, 10, 12, 9, 1, 6, 7, 8, 0, 14, 5, 13, 4])
d = lut.difference_distribution_table() # a SAGE Matrix object
spectrum = defaultdict(int)
for a in range(1, d.nrows()): # we start at 1 because 0 is pointless
    for b in range(0, d.ncols()):
        spectrum[d[a][b]] += 1
print(spectrum)
#+END_SRC

- Advantages :: pure SAGE, no need to download/install =sboxU=; performances are usually good enough; can handles output sizes different from the input sizes.
- Downsides :: rather slow, which is a problem if S-boxes get bigger; need to re-implement the differential spectrum computation; differential spectrum computation is memory inefficient.

  
- Q? :: Compute the differential spectrum of the S-box of the =AES=. Any pattern? Count how many times each coefficient appears in each row/column. Any pattern? Any idea why?
- Q? :: Write a function computing the differential spectrum of an S-box without having to store the full DDT in memory.

**** 3.2.a.ii) Using sboxU
As a general rule, the functions in sboxU are much better optimized (lower memory and much lower time complexities, at least because they are written in C++). It relies on lower level types than SAGE, meaning that an S-box is just a =list=, and a DDT is a =list= of =list=. There is also more of them. For example, the same as above can be done using the following.


#+BEGIN_SRC python
from sboxU import *

lut = [11, 15, 3, 2, 10, 12, 9, 1, 6, 7, 8, 0, 14, 5, 13, 4]
d = ddt(lut)
spectrum = differential_spectrum(lut)
print(pretty_spectrum(spectrum))
#+END_SRC


- Q? :: Consider a 16x16 S-box built like an SPN which is equal to =S o L o S=, where =S= is the parallel application of the =PRINCE= S-box (it is in =sage.crypto.sboxes=), and =L= maps =(x0, x1, x2, x3)= to =(x0^t, x1^t, x2^t, x3^t)=, where =^= is the XOR, and where =t = x0^x1^x2^x3=. What is its differential uniformity?

*Warning:* In SAGE, =^= is sometimes a XOR and sometimes an exponential. To solve this problem, you can use the =oplus= function of sboxU that directly calls the C++ =^=, so that =t = oplus(oplus(x0, x1), oplus(x2, x3))=.
*** 3.2.b) Linear Properties

The *Linear Approximation Table (LAT)* of an S-box =s= over =n= bits is a two dimensional array =l= such that, in our case:
#+BEGIN_SRC python
l[a][b] = sum((-1)**(scalar_prod(a, x) + scalar_prod(b, S[x]) for x in range(0, 2**n))
#+END_SRC

where =scalar_prod= implements a scalar product over $F_2^n$, such as $<a,x> = \sum_i a_i x_i \mod 2$.

The *Walsh spectrum* counts how many pairs =(a,b)= exist such that =l[a][b] = c=, where =a!=0=. The =extended Walsh spectrum= is the same, except that we look at the absolute values. The maximum non-zero coefficient in the latter is the *linearity* of =s=.

**** 3.2.a.i) Using pure SAGE
To compute the LAT of the S-box of the PRINCE block cipher, and then its extended Walsh spectrum, we do as follows.

#+BEGIN_SRC python
from sage.crypto.sbox import SBox  # we import the SBox class
from collections import defaultdict # a dictionary replacement

lut = SBox([11, 15, 3, 2, 10, 12, 9, 1, 6, 7, 8, 0, 14, 5, 13, 4])
d = lut.linear_approximation_table() # a SAGE Matrix object
spectrum = defaultdict(int)
for a in range(1, d.nrows()): # we start at 1 because 0 is pointless
    for b in range(0, d.ncols()):
        spectrum[abs(d[a][b])] += 1
print(spectrum)
#+END_SRC

Advantages and inconvenients are the same as for the differential case.
- Advantages :: pure SAGE, no need to download/install =sboxU=; performances are usually good enough; can handles output sizes different from the input sizes.
- Downsides :: rather slow, which is a problem if S-boxes get bigger; need to re-implement the Walsh spectrum computation; walsh spectrum computation is memory inefficient.

  
- Q? :: Compute the extended Walsh spectrum of the S-box of the =AES=. Any pattern? Count how many times each coefficient appears in each row/column. Any pattern? Any idea why? (hint: the why is exactly the same as before!)

**** 3.2.a.ii) Using sboxU
As before, sboxU can do the same, but quicker.

#+BEGIN_SRC python
from sboxU import *

lut = [11, 15, 3, 2, 10, 12, 9, 1, 6, 7, 8, 0, 14, 5, 13, 4]
d = lat(lut)
spectrum = walsh_spectrum(lut)
print(pretty_spectrum(spectrum, absolute=True))
#+END_SRC

Note the =absolute=True= parameter given to the =pretty_spectrum= function: it ensures that we print the extended Walsh spectrum, not the Walsh spectrum itself.

sboxU provides the =scal_prod= function, which we will discuss later.

- Q? :: Consider the same 16x16 S-box as above. What is its linearity?

It is also possible to *invert* a LAT, i.e., given an LAT, to return the corresponding function. This can be done with the =invert_lat= function.

- Q? :: Looking at the S-box of =PRINCE=, compute its lat, print it, and then call =invert_lat= in it. Did it work? Now, swap to rows of the lat, and =invert_lat= again. What do you get?

*** 3.2.c) Boomerang Properties
The *Boomerang Connectivity Table (BCT)* is also present in both SAGE and sboxU (=SBox.boomerang_connectivity_table()= for SAGE, =bct= for sboxU), and the spectrum is only in sboxU (=boomerang_spectrum(lut)=).
*** 3.2.d) Jackson Pollock Representation
(Yes, that's a thing; yes, it's my fault)

For S-boxes operating on more than 5 bits, it can be more convenient to make a graph representing the coefficients rather than just displaying their values in a terminal. This can be surprisingly powerful: most S-box structures used to build S-boxes "in real life" can be spotted directly on such representations of the DDT, LAT or BCT.

To simplify such things, sboxU provides the =save_pollock= function, which is used as follows, where =t= is a list of list (typically, the output of =ddt= or =lat=). By default, it applies the =abs= function to all the elements.

#+BEGIN_SRC python
save_pollock(t,
             name="where_to_save", # mandatory parameter, specifies the path the png file you want to generate
             vmin=0, # values under this threshold are shown as equal to this threshold
             vmax=0, # values above this threshold are shown as equal to this threshold
             color_scheme="coolwarm" # a string description of the color scheme to use.
             )
#+END_SRC

- Q? :: Generate the picture representation of the LAT of the S-box of =Kuznyechik=. Play around with the values of =vmax= and the =color_scheme= (try ="spectral"=, ="Greys"=, ="coolwarm"=). Anything strange?


** 3.3) Algebraic normal form
compute ANF

- Q :: compose S-box with a basic linear layer. Regenerate ANF. Make the same thing directly on the ANF.

* 4) S-box Representations
Integer, field element, bit-string: how they can bite you

* 5) The Only Known APN Permutation in Even Dimension

The following is also =list(sage.crypto.sboxes.sboxes["APN_6"])=.

#+BEGIN_SRC python
dillon = [0, 54, 48, 13, 15, 18, 53, 35, 25, 63, 45, 52, 3, 20, 41, 33, 59, 36, 2, 34, 10, 8, 57, 37, 60, 19, 42, 14, 50, 26, 58, 24, 39, 27, 21, 17, 16, 29, 1, 62, 47, 40, 51, 56, 7, 43, 44, 38, 31, 11, 4, 28, 61, 46, 5, 49, 9, 6, 23, 32, 30, 12, 55, 22]
#+END_SRC

- Q :: What are the main cryptographic properties of this function?
- Q :: Does this Walsh spectrum ring a bell?k

