#+TITLE: The Tools of the Trade: Things a Symmetric Cryptographer Should Know How To Do

* 1) Writing
** 1.1) Text Editor
Pick one text editor (/maybe/ two), and learn how to use it *well*:
- find, test, and then use the plugins that can be relevant to how you work,
- figure out how to quickly navigate a file (jump to next section/jump to function),
- learn the keyboard shortcuts,
- setup a spell checker.

Well known/popular general purpose text editors include:
1. EMACS (GNU license, i.e., free)
2. Vi/Vim/neoVim (Apache, i.e., free)
3. Sublime Text (Proprietary, but can be used for free to some extent)
4. Visual Code  (Proprietary, but can be used for free to some extent)

I personally prefer to stay away from web-based tools like =overleaf=: the internet can go down, and the editor itself cannot be customized.

- Q? (1) :: Which text editor do you use? Why did you choose it?
** 1.2) Beamer Hacks
Along with the slides themselves, I have put their source code in the corresponding folder of this repository: feel free to "borrow" any macro you see there!

To compile it, you will need the "INRIA" font (see for example [[https://fonts.google.com/specimen/Inria+Serif][here]]) and =xelatex= rather than =pdflatex=. Simply remove the lines about setting the font in =style.tex= to get rid of this setting.
*** 1.2.a) Beamer theme
A gallery of all default beamer themes is available [[https://deic.uab.cat/~iblanes/beamer_gallery/][here]].

*** 1.2.b) Beamer Automated ToC Display
Add the following code snippet before your beamer presentation to be able to display the outline of the talk, and then the outline of the relevant section in the beginning of each section. This display starts at the point at which you write =\tocStartsAppearingHere{}=.

#+BEGIN_SRC latex
\newcommand\tocStartsAppearingHere{ %
  \begin{frame}[noframenumbering]
    \frametitle{Outline}
    \tableofcontents[
    sectionstyle=show,
    subsectionstyle=hide,
    subsubsectionstyle=hide] 
  \end{frame}

  \AtBeginSection[] { %
    \begin{frame}[noframenumbering]
      \frametitle{Plan of this Section}
      \tableofcontents[
      currentsection,
      currentsubsection,
      sectionstyle=show/shaded,
      subsectionstyle=show/hide/hide,
      subsubsectionstyle=hide]
    \end{frame}
  }

  \AtBeginSubsection[] { %
    \begin{frame}[noframenumbering]
      \frametitle{Plan of this Section}
      \tableofcontents[
      currentsection,
      currentsubsection,
      sectionstyle=show/shaded,
      subsectionstyle=show/shaded/hide,
      subsubsectionstyle=hide]
    \end{frame}
  }
}

#+END_SRC

*** 1.2.c) Use Some Color
Syntax highlighting greatly helps with reading a program. Mathematics are not that different, and a well chosen color scheme can greatly help convey information. For example, if all the functions are blue, or if all the linear functions are in a different color from the non-linear ones, then your talk might be even clearer. The following macro helps with that:

#+BEGIN_SRC latex
\newcommand{\defcolvar}[3]{%
  \expandafter\newcommand\csname my#1\endcsname{{\color{#3} #2 }} %
}
#+END_SRC

To use it, add for example =\defcolvar{alpha}{\alpha}{red}= at any point of your code. From that point onwards, the macro =\myalpha= (note the =my=) will correspond to a red $\alpha$. Similarly, =\defcolvar{n}{n}{blue}= will allow you to use =\myn= to display a blue n. It simplifies the use of colors, and encourages the usage of consistent colorization throughout the code: both are good!
*** 1.2.d) Dynamic Slides
In beamer, each =frame= can be divided into multiplies =slides=. The slides are generated automatically using some macros inside the frame, and can for instance correspond to subsets of the content of the frame. A typical example is an =itemize= list where the items appear one after another: the frame is divided into slides, where each slide contains one more item than the previous one. To use this concept, you can use the following commands. Some of them take an index as an argument: it is the index of the slide in which you want things to happen. It can also be a range: =<2-4>= will have something happen on slides 2, 3 and 4 only; while =<2->= will have something from slide 2 and onwards.

- =\pause= :: Creates a copy of the current slide, one with the content generated by parsing what is before the =\pause=, and one with the same content *and* the one that is after the =\pause=. The rendering is "aware" of what will be displayed next: the slides before and after the pause have an identical beginning.

- =\onslide<index>{ ... }= :: The content of the macro will be displayed only on the given slide(s), but space will be reserved for it. For instance, the behaviour of =\pause= can be seen as wrapping what is after it in =\onslide<(i+1)->=, where =(i+1)= is replaced by the relevant index.

- =\only<index>{ ... }= :: Same as =\onslide=, except nothing clever is done about space: the LaTeX code is contained is included in the given slides, and is completely ignored in the other ones.
  
- Q? (2) :: make a presentation with a slide containing a table where some numbers change weight (bold or not bold) as you hit "next".

** 1.3) Other LaTeX Tricks
*** 1.3.a) Setting some lengths
In the following macros, =0.3cm= and =1.1= can be changed to whatever you like.
- =\setlength\itemsep{0.3cm}= :: Sets the space between the different items. A high value means a high space, while a negative value brings the lines even closer together. Putting this after =\begin{itemize}=, =\begin{enumerate}= or =\begin{description}= (and before the =\item=) is a convenient way to set it for a single environment.
- =\setlength\tabcolsep{0.3cm}= :: Sets the horizontal space between columns. A high value means they will be far apart. Put it inside the =table= environment (but outside the =tabular= one) to limit its scope.
- ={\renewcommand\arraystretch{1.1} <your table>}= :: This multiplies the vertical size of a table by the given amount; very useful to increase the height of its rows. 
* 2) Basic Command Line Tools
** TODO 2.1) top and htop
** TODO 2.2) grep
Basic usage

regexp

some nice options: -A, -B, -n, -i
** TODO 2.3) text manipulation
sed

wc

cut -d $delimiter -f $index

cut -d $delimiter -f $indicesStart-indicesEnd
** TODO 2.4) scripting (sh/zsh)

* 2) Programming
** TODO 2.1) Structuring a Program
Distinction draft/proper writeup exists in programming

Function = Lemma

Tree structure: in the directory/subdirectories logic, also within a file (that's what you do when you write a paper).

main program
** 2.2) Not so Basic Python Features
*** TODO Object Oriented Programming
*** TODO Detecting Problems Early
assert

Exception

*** TODO Optional Arguments

*** Creating a module
You should strive for re-usability of your code. In order for it to be easy to reuse, the best way is to turn it into a module that you will simply load in your subsequent work. If your library is small, you can keep it to a single file. However, having a multi-file module is not that hard. Both are explained below.
**** Single file
If your code is in a single file, then reusing it elsewhere is straightforward: simply use the =import= mecanism. For example, supposed you have the following file (=yourLib.py=) in a directory.
#+BEGIN_SRC python :tangle py/yourLib.py
def basic_function():
    print("something")

constant = 3
#+END_SRC

Then you can reuse it by loading it from another file, say =mainFile.py=, as long as it is in the same directory. You can do it in two different ways.

First way, where you need to explicitely mention =yourLib= when you use its content.
#+BEGIN_SRC python :tangle py/mainFile-single.py
import yourLib # <- note the absence of ".py"

yourLib.basic_function()
print("constant from yourLib = ", yourLib.constant)
#+END_SRC

Second way, where you don't need to (which is nice), but which could lead to conflicts in names if you are not careful (which is less nice).

#+BEGIN_SRC python :tangle py/mainFile-single-bis.py
from yourLib import basic_function, constant

basic_function()
print("constant from yourLib = ", constant)
#+END_SRC

In the second case, in order to mention one by one all the functions you want to import, just use =from yourLib import *= instead.

**** Multiple files
Suppose your library is big enough that you can't get away with just one file. The idea in this case is that you will put all of these in a folder, and then import this folder. For example, you can create the folder =yourModule=, and put two files in it that are as follows:

=yourModule/first.py= contains the same as before...

#+BEGIN_SRC python :tangle py/yourModule/first.py
def basic_function():
    print("something")

constant = 3
#+END_SRC

... and =yourModule/second.py= contains another piece of impressive software engineering.

#+BEGIN_SRC python :tangle py/yourModule/second.py
def sophisticated_function():
    result = "something"
    result += " sophisticated"
    print(result)

other_constant = 4
#+END_SRC

You then simply need to add the following file called =__init__.py= to this folder...

#+BEGIN_SRC python :tangle py/yourModule/__init__.py
from .first import *
from .second import *
#+END_SRC

... so that the directory tree is:
- =theProjectYouWorkOn/=
  - =mainFile.py=
  - =yourModule/=
    - =first.py= 
    - =second.py= 
    - =__init__.py= 

The following =mainFile.py= will then work as expected: importing =yourModule= will run the =__init__.py= script, and provide you with the functions contained in the =first.py= and =second.py= files. 
      
#+BEGIN_SRC python :tangle py/mainFile-module.py
from yourModule import *

basic_function()
sophisticated_function()
print("other constant = ", other_constant)
#+END_SRC

You can add some logic in the =__init__.py= script to decide which of the files you want to import, for instance by testing which OS your user is using and/or which python/SAGE version.

*** Adding Some C++ to It
Basic case of functions.

Classes is left as an exercise.
** 2.3) Some helpful links
- =Rich= is a python module that can easily make your terminal output much prettier---and thus much easier to parse. [[https://rich.readthedocs.io/en/stable/introduction.html][Link]].
* Storing and Retrieving Information
** "Knowledge Management Systems"
*** To keep notes
"personal wiki" "second brain"
*** Accumulating knowledge
=templates= folder?

file with LaTeX macros
** cryptobib
*** Getting it
basic download from https://cryptobib.di.ens.fr/

as a git submodule
*** Application
- Q? :: What is the cryptobib bibtex key for the paper introducing the =Griffin= hash function?
- Q? :: Write a short shell script taking as input part of the title of a paper and which returns its bibtex key. 

* Working Together
** =git= (basics)
** Overleaf
Exists and is used, so you should know how to use it. In particular, learn how to download a complete project, and do it on a regular basis if you use it (as a security measure).

Also, I would not recommend relying on it too much: it can crash (and then you are stuck), and it can force your co-authors to use its text editor rather than their customized and optimized personal one.

* Additional Resources
- MIT "missing semester :: Students from MIT have put online resources about the tools they need to master for the CS education, which are of course very similar to those needed for cryptography research. It has its own [[https://missing.csail.mit.edu/][website]].
- MPRI classes :: MPRI is a master's degree in Paris focused on theoretical computer science. The content of its courses is online, in particular, the following link will take you to a class on "Efficient Algorithms in Computer Algebra": [[https://wikimpri.dptinfo.ens-cachan.fr/doku.php?id=cours:c-2-22][link]].

